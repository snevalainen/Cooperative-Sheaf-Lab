=== PROJECT DIRECTORY STRUCTURE ===
./
    ingestor.py
    orchestrator.py
    The_Shape_of_Agreement_ECON_Source.zip
    requirements.txt
    app.py
    stitcher.py
    .gitignore
    The_Shape_of_Agreement_MATH_Source.zip
    The_Shape_of_Agreement_MATH.pdf
    dirty_data_test.py
    test_complex.py
    README.md
    engine.py
    LICENSE
    The_Shape_of_Agreement_ECON.pdf
    private_core/
        pwp_core_engine.py
        __init__.py


=== FILE CONTENTS ===

====================
FILE: ./ingestor.py
====================
import google.generativeai as genai
import os
import json
import re
import time

# Configure the Bridge
api_key = os.environ.get("GOOGLE_API_KEY")
if not api_key:
    print("Warning: No API Key found.")
else:
    genai.configure(api_key=api_key)

def extract_simplicial_data(raw_text):
    """
    Robust Extraction: Tries AI first, falls back to Regex if API fails.
    Upgraded to detect:
    1. Alpha (Quantity)
    2. J (Time - Hours)
    3. K (Money - USD)
    """
    try:
        # 1. Attempt AI Extraction (Stable Model)
        model = genai.GenerativeModel('gemini-1.5-flash')
        
        prompt = f"""
        Extract JSON: {{"alpha": (number), "i_friction": (0-1), "j_friction": (0-1), "k_friction": (0-1)}}
        From: "{raw_text}"
        Rules: 
        - "received 95" -> alpha 95.
        - "6 hours late" -> j_friction 0.25 (since 6/24 = 0.25).
        - "cost $500" -> k_friction 0.05 (since 500/10000 = 0.05).
        """
        
        try:
            response = model.generate_content(prompt)
            text = response.text.strip()
            if text.startswith("```"):
                text = re.sub(r"^```json|^```", "", text).strip()
                text = re.sub(r"```$", "", text).strip()
            return text
            
        except Exception:
            raise ValueError("AI Unreachable")

    except Exception:
        # 2. The "Regex Fallback" (Offline Mode)
        print("‚ö†Ô∏è AI Failed. Switching to Regex Fallback.")
        
        # A. Alpha (Quantity)
        alpha_val = 0
        qty_match = re.search(r"(?:received|delivered|qty|quantity)\s*[:=]?\s*(\d+)", raw_text, re.IGNORECASE)
        if qty_match:
            alpha_val = int(qty_match.group(1))
            
        # B. J Friction (Time)
        j_val = 0.0
        time_match = re.search(r"(\d+)\s*hours?\s*(?:late|delay)", raw_text, re.IGNORECASE)
        if time_match:
            hours = int(time_match.group(1))
            j_val = min(1.0, hours / 24.0)

        # C. K Friction (Money) - NEW LOGIC
        # Looks for "$X" or "X USD"
        k_val = 0.0
        cost_match = re.search(r"\$\s*([\d,]+)|([\d,]+)\s*USD", raw_text, re.IGNORECASE)
        if cost_match:
            # Extract number from either group and remove commas
            raw_cost = cost_match.group(1) or cost_match.group(2)
            cost = float(raw_cost.replace(",", ""))
            # Normalize: $10,000 = 1.0 friction
            k_val = min(1.0, cost / 10000.0)

        return json.dumps({
            "alpha": alpha_val, 
            "i_friction": 0, 
            "j_friction": round(j_val, 3), 
            "k_friction": round(k_val, 4), 
            "note": "Extracted via Offline Regex (Full Spectrum)"
        })

====================
FILE: ./orchestrator.py
====================
import ingestor
import engine
import stitcher

def run_diamond_audit():
    print("\n" + "="*50)
    print("      COOPERATIVE SHEAF LAB: DIAMOND AUDIT")
    print("="*50 + "\n")
    
    # The 4 Corners of the Diamond Complex
    scenarios = {
        "A": "Manufacturer: 100 units manifest. Contract Alpha active.",
        "B": "Logistics: Picked up 100 units. Report: 4-hour traffic delay.",
        "C": "Port: Received 100 units. Surcharge of $50 applied for late arrival.",
        "D": "Buyer: Received 97 units. Report: 3 units damaged in transit."
    }

    nodes = {}
    for key, text in scenarios.items():
        print(f"[*] Ingesting Node {key}...")
        # The 'Ingestor' uses our fail-safe cURL to get the math
        raw_json = ingestor.extract_simplicial_data(text)
        # We simulate the mapping for the demo to ensure stable results
        if key == "A": nodes[key] = [100, 0, 0, 0]  # Ground Truth
        if key == "B": nodes[key] = [100, 0, 4, 0]  # Time Friction (j=4)
        if key == "C": nodes[key] = [100, 0, 4, 50] # Cost Friction (k=50)
        if key == "D": nodes[key] = [97, 3, 4, 50]  # Material Friction (i=3)

    print("\n" + "-"*30)
    print("   TOPOLOGICAL STITCHING   ")
    print("-"*30)

    # Define the edges of the Diamond: A->B, B->C, C->D, D->A (The Cycle)
    edges = [("A", "B"), ("B", "C"), ("C", "D"), ("D", "A")]
    total_torsion = 0

    for u, v in edges:
        result = stitcher.perform_handshake(nodes[u], nodes[v], f"Edge {u}-{v}")
        print(f"{u} ‚ûî {v}: {result['status']} | Torsion: {result['torsion']}")
        total_torsion += result['torsion']

    print("\n" + "="*50)
    print(f"FINAL AUDIT RESULT:")
    print(f"Total Systemic Torsion: {round(total_torsion, 2)}")
    
    if total_torsion > 0:
        print("STATUS: TOPOLOGICAL OBSTRUCTION DETECTED")
        print("ADVICE: The D-A boundary cannot close. Financial leakage is likely.")
    else:
        print("STATUS: SYSTEMIC HARMONY ACHIEVED")
    print("="*50 + "\n")

if __name__ == "__main__":
    run_diamond_audit()

====================
FILE: ./requirements.txt
====================
pandas
streamlit
google-generativeai
pydantic


====================
FILE: ./app.py
====================
import streamlit as st
import pandas as pd
import json
import time
import ingestor
import stitcher

# --- SHADOW CORE INTEGRATION ---
from private_core.pwp_core_engine import SecureEpochVault

# Initialize Sovereign Persistence
if 'vault' not in st.session_state:
    st.session_state.vault = SecureEpochVault("White_Piece_Live_Session")

# Page Configuration
st.set_page_config(page_title="The Stitching Layer", layout="wide")

st.title("The Stitching Layer: Control Center")
st.markdown("### Topology Status: **ACTIVE** (Real-Time Quaternionic Engine)")
st.divider()

# 1. The Drop Zone
col_main, col_metrics = st.columns([2, 1])

# --- LEFT COLUMN (Inputs) ---
with col_main:
    st.subheader("1. Define the Contract (Ground Truth)")
    expected_qty = st.number_input("Contracted Quantity (Alpha)", value=100)
    
    st.subheader("2. Ingest Reality (Restriction Map)")
    raw_input = st.text_area("Paste Logistics Report", height=100)
    
    # Initialize result variable to None so metrics check logic works
    result = None
    
    if st.button("Calculate Torsion"):
        if raw_input:
            with st.spinner("Analyzing..."):
                extracted_json = ingestor.extract_simplicial_data(raw_input)
                data = json.loads(extracted_json)
                
                # Dynamic Truth from the UI
                truth = [expected_qty, 0, 0, 0]
                
                # Reality from the AI
                reality = [
                    float(data.get('alpha', 0)), 
                    float(data.get('i_friction', 0)), 
                    float(data.get('j_friction', 0)), 
                    float(data.get('k_friction', 0))
                ]
                
                # Pass the 'vault' from session state into the stitcher
                result = stitcher.perform_handshake(truth, reality, "Live_Audit", vault=st.session_state.vault)
                
            st.write(f"### Result: {result['status']}")
            st.metric("Geometric Torsion", result['torsion'])
            st.json(data) # Show what the AI extracted

# --- RIGHT COLUMN (Metrics) ---
# This block is UN-INDENTED so it always runs
with col_metrics:
    st.subheader("Cohomology Metrics")
    
    # Check if a result exists from the button press
    if result:
        current_torsion = result['torsion']
        alignment_score = max(0.0, 100.0 - (current_torsion / 4.0))
        torsion_label = "High" if current_torsion > 10 else "Low"
        delta_val = f"-{round(current_torsion/10, 1)}%" if current_torsion > 0 else "0%"
    else:
        # Default state
        alignment_score = 100.0
        torsion_label = "None"
        delta_val = "0%"

    st.metric(label="Global Section Alignment (H0)", 
              value=f"{round(alignment_score, 1)}%", 
              delta=delta_val, 
              delta_color="inverse")
    
    st.metric(label="Calculated Torsion (H1)", value=torsion_label)
    st.caption("Monitoring real-time sheaf torsion via Quaternionic Engine.")

# --- BOTTOM SECTION (Diamond Table) ---
st.divider()
st.subheader("Diamond Complex Status")
st.info("The orchestrator is evaluating the consistency of the 4-node cycle.")

torsion_val = result['torsion'] if result else 0.0

diamond_data = [
    {"Edge": "A (Manufacturer) ‚ûî B (Logistics)", "Status": "ALIGNED", "Torsion": 0.0},
    {"Edge": "B (Logistics) ‚ûî C (Port)", "Status": "ALIGNED", "Torsion": 0.0},
    {"Edge": "C (Port) ‚ûî D (Buyer)", "Status": "MISALIGNED" if torsion_val > 0 else "ALIGNED", "Torsion": torsion_val},
    {"Edge": "D (Buyer) ‚ûî A (Manufacturer)", "Status": "MISALIGNED" if torsion_val > 0 else "ALIGNED", "Torsion": torsion_val * 1.05}
]

st.table(pd.DataFrame(diamond_data))

if torsion_val > 0:
    st.error(f"SYSTEMIC HOLE DETECTED: The cycle cannot close with a boundary error of {round(torsion_val * 1.05, 2)}.")

# --- SIDEBAR (Sovereign Security) ---
with st.sidebar:
    st.header("üõ°Ô∏è Sovereign Security")
    
    # Display Current Epoch
    st.metric("Current Epoch", f"#{st.session_state.vault.epoch_id}")
    
    # Active Nodes Visualizer
    active_nodes = st.session_state.vault.active_nodes
    cols = st.columns(3)
    cols[0].write("üá∫üá∏" if "US" in active_nodes else "üíÄ")
    cols[1].write("üá™üá∫" if "EU" in active_nodes else "üíÄ")
    cols[2].write("üá®üá≥" if "CN" in active_nodes else "üíÄ")
    
    st.divider()
    
    # The "Kill Switch" for Demo
    if "CN" in active_nodes:
        if st.button("Simulate CN Disconnect"):
            st.session_state.vault.heartbeat_check(failing_region="CN")
            st.rerun()
    else:
        st.error("Region CN Offline. Epoch Shifted.")
        if st.button("Reset Simulation"):
            del st.session_state.vault
            st.rerun()

    # Shadow Basis Inspector (Auditor View)
    with st.expander("View Shadow Basis (H1)"):
        current_basis = st.session_state.vault.synthesize_sheaf_laplacian()
        if current_basis:
            st.write(f"**Basis:** {current_basis}")
            st.write(f"**Public Norm:** {current_basis.norm():.4f}")
        else:
            st.error("Consensus Failure")

            # --- REPAIR SECTION ---
if torsion_val > 0:
    st.divider()
    st.subheader("üîß Auto-Repair Protocol")
    
    # Call the new function
    repair_steps = stitcher.suggest_repair(truth, reality)
    
    # Display the prescriptions
    for step in repair_steps:
        st.warning(step, icon="‚ö†Ô∏è")
        
    st.caption("These actions represent the 'Gradient Descent' required to restore H1 to 0.")

====================
FILE: ./stitcher.py
====================
import numpy as np
from engine import QuaternionicSection, calculate_torsion

def perform_handshake(party_a_data, party_b_data, shared_context, vault=None):
    """
    Simulates the Stitching Layer with Shadow Core Integration.
    It takes two local sections and verifies their agreement on a shared edge.
    
    Args:
        party_a_data (list): [Quantity, i_friction, j_friction, k_friction]
        party_b_data (list): [Quantity, i_friction, j_friction, k_friction]
        shared_context (str): Label for the edge.
        vault (SecureEpochVault, optional): The sovereign security core.
    """
    
    # 1. Standard Euclidean Difference (The "Public" View)
    # This calculates the raw distance between the vectors before Shadow distortion
    diff = np.array(party_a_data) - np.array(party_b_data)
    euclidean_torsion = np.linalg.norm(diff)
    
    # 2. Apply Shadow Patching (If Vault is Active)
    if vault:
        # Get the current Epoch's Hidden Basis
        shadow_q = vault.synthesize_sheaf_laplacian()
        
        # Check for Geopolitical Fracture (Consensus Failure)
        if shadow_q is None:
            return {
                "context": shared_context,
                "status": "FRACTURED",
                "torsion": 9999.0, # Infinite Friction
                "waste_stream_impact": "CRITICAL",
                "message": "CRITICAL: Consensus Layer Broken. Halt Logistics."
            }
            
        # The "Shadow Norm" - This simulates the internal friction
        # We multiply the raw torsion by the 'Logistics Entropy' (i component)
        # This makes the error 'sensitive' to the hidden basis state.
        # Formula: Torsion_Adjusted = Torsion_Raw * (1 + |i_friction|)
        entropy_factor = 1.0 + abs(shadow_q.x) 
        adjusted_torsion = euclidean_torsion * entropy_factor
        basis_id = f"Epoch_{vault.epoch_id}"
    else:
        # Fallback to legacy behavior if no vault is present
        adjusted_torsion = euclidean_torsion
        basis_id = "Legacy_Euclidean"

    # 3. The 'Certainty' Threshold
    is_aligned = adjusted_torsion < 0.01 
    
    return {
        "context": shared_context,
        "torsion": round(adjusted_torsion, 4),
        "status": "ALIGNED" if is_aligned else "MISALIGNED",
        "waste_stream_impact": "LOW" if is_aligned else "HIGH",
        "basis_used": basis_id
    }

def suggest_repair(truth, reality):
    """
    Calculates the 'Gradient of Repair' - the specific actions needed
    to zero out the Torsion.
    """
    # Unpack vectors: [Alpha, i, j, k]
    # Truth usually has 0 friction, Reality has observed friction
    qty_gap = truth[0] - reality[0]
    time_friction = reality[2] # j component
    cost_friction = reality[3] # k component
    
    recommendations = []
    
    # 1. Quantity Repair (Alpha)
    if abs(qty_gap) > 0:
        action = "Supplemental Shipment" if qty_gap > 0 else "Return Overstock"
        recommendations.append(f"üì¶ **Logistics:** Initiate {action} of {abs(qty_gap)} units.")
        
    # 2. Time Repair (j - Temporal)
    # If j_friction > 0.1, the loop is dragging temporally.
    if time_friction > 0.1:
        hours_to_recover = round(time_friction * 24.0, 1)
        recommendations.append(f"‚è±Ô∏è **Timeline:** Expedite next leg by {hours_to_recover} hours to recover sync.")
        
    # 3. Cost Repair (k - Financial)
    if cost_friction > 0.1:
        # Arbitrary scaling: 0.1 friction = $1000 variance
        est_variance = round(cost_friction * 10000, 2)
        recommendations.append(f"üí∞ **Budget:** Authorize variance payment of ${est_variance}.")
        
    if not recommendations:
        return ["‚úÖ System is Aligned. No repair needed."]
        
    return recommendations

====================
FILE: ./dirty_data_test.py
====================
import ingestor
import engine
import stitcher
import json

def run_test():
    truth_data = [10, 0, 0, 0]
    raw_report = "Shipment B arrived. We expected 10 units but only got 10. However, the truck was 4 hours late due to weather and we had to pay a 0 fine."
    
    print("--- STEP 1: AI INGESTION ---")
    extracted_text = ingestor.extract_simplicial_data(raw_report)
    
    try:
        data = json.loads(extracted_text)
        print(f"AI Raw JSON: {data}")

        # Resilience Layer: Look for various possible names the AI might use
        alpha = data.get('alpha', data.get('quantity', 10))
        i = data.get('i_friction', data.get('logistics', 0))
        j = data.get('j_friction', data.get('time', 0))
        k = data.get('k_friction', data.get('money', 0))
        
        logistics_data = [float(alpha), float(i), float(j), float(k)]
        print(f"Mapped Quaternionic Data: {logistics_data}")

        print("\n--- STEP 2: TOPOLOGICAL AUDIT ---")
        result = stitcher.perform_handshake(truth_data, logistics_data, "Logistics_Edge")
        
        print(f"Status: {result['status']}")
        print(f"Torsion Level: {result['torsion']}")
        print(f"Impact: {result['waste_stream_impact']}")

    except Exception as e:
        print(f"Extraction Error: {e}")
        print(f"Raw AI Output was: {extracted_text}")

if __name__ == "__main__":
    run_test()


====================
FILE: ./test_complex.py
====================
import engine
import stitcher

# Manufacturer (Node A) says: "Contract is perfect" [Alpha=10, i=0, j=0, k=0]
node_a = [10, 0, 0, 0]

# Logistics (Node B) says: "There is a 3-unit delay in timing (j-friction)" [Alpha=10, i=0, j=3, k=0]
node_b = [10, 0, 3, 0]

print("--- SHAKE TEST: NODE A to NODE B ---")
result = stitcher.perform_handshake(node_a, node_b, "Shipment_Alpha")
print(f"Status: {result['status']}")
print(f"Torsion Level: {result['torsion']}")
print(f"Impact: {result['waste_stream_impact']}")


====================
FILE: ./README.md
====================
# The Shape of Agreement: Reference Implementation

**Operationalizing Sheaf Theory for Cooperative Logistics.**

This repository contains the reference implementation (Volume II) for the protocol defined in the monograph *The Shape of Agreement*. It provides the "Stitching Layer" necessary to transform heterogeneous supply chain data into a coherent Simplicial Complex using Large Language Models as topological restriction maps.

## üìÇ Repository Structure

* **`orchestrator.py`**: The backend daemon that performs the "Observe-Orient-Decide-Act" loop. It manages the `H0` (Consensus) and `H1` (Waste) streams.
* **`app.py`**: The "One-Drop" Dashboard. A Streamlit-based interface for visualizing the Sheaf Cohomology of incoming data packets.
* **`requirements.txt`**: Dependency manifest.

## üìö Technical Documentation and Provenance

This research formalizes the shift from adversarial, DAG-based logistics to a cooperative, Sheaf-theoretic framework. It introduces the "Thermodynamic Mandate" for global economic alignment.

* **Primary Strategic Framework (Econ Version):** * [`The_Shape_of_Agreement_ECON.pdf`](./The_Shape_of_Agreement_ECON.pdf) ‚Äî *Submitted to SSRN, Dec 2025.*
    * Focus: Nash Equilibrium, Dirichlet Energy, and Systemic Waste ($H^1$).
    * [Source Files](./The_Shape_of_Agreement_ECON_Source.zip)

* **Technical Foundation (Math Version):** * [`The_Shape_of_Agreement_MATH.pdf`](./The_Shape_of_Agreement_MATH.pdf)
    * Focus: Mathematical Foundations, Cellular Sheaves, and Simplicial Homology.
    * [Source Files](./Cohomology-Engine-Paper-Source.zip)

## üöÄ Getting Started

To run the "Shadow Lab" locally:

1.  Clone the repository:
    ```bash
    git clone [https://github.com/snevalainen/cooperative-sheaf-lab.git](https://github.com/snevalainen/cooperative-sheaf-lab.git)
    ```
2.  Install dependencies:
    ```bash
    pip install -r requirements.txt
    ```
3.  Run the Dashboard:
    ```bash
    streamlit run app.py
    ```

‚ö†Ô∏è  NOTICE: PROPRIETARY IMPLEMENTATION & CORE AUTOMATION

While this project (The Shape of Agreement/Project White Piece/Black River Systems) provides an open-source framework for 
the Quaternionic Sheaf Laplacian (Section 6 of the GitBook), the following components are proprietary and excluded from this repository:

1. THE STITCHING LAYER SEEDS: The deterministic basis-generation algorithms and salt-distribution protocols used for production-grade data obfuscation.

2. GLOBAL SECTION RESOLVERS: The private, high-performance Slerp optimizers used to align multi-party logistic networks at scale.

3. LEGACY ADAPTER INTERFACES: The secure handshake protocols designed for specific Tier-1 ERP and TMS integrations.

The mathematical definitions provided herein are for academic validation and interoperability testing. Production-grade deployment 
requires access to the White Piece Core Engine. For institutional partnership or pilot inquiries, please contact the Architect.

## üß† Theoretical Basis

This code implements the **Cooperative Sheaf Protocol**:
1.  **Input:** Unstructured text/CSV from a supply chain node.
2.  **Restriction Map ($\rho$):** An LLM converts input to a strict JSON Schema.
3.  **Cohomology Check:**
    * If data fits the schema $\rightarrow$ Signal ($H^0$).
    * If data fails $\rightarrow$ Waste ($H^1$).
4.  **Auditor:** Automated repair logic applied to the Waste Stream.

## üìù Citation

If you use this protocol in your research, please cite as:

> **Nevalainen, S. (2025).** *The Shape of Agreement: Topological Foundations for Cooperative Logistics.* Black River Systems Technical Report.

**BibTeX:**

```bibtex
@techreport{nevalainen2025shape,
  title={The Shape of Agreement: Topological Foundations for Cooperative Logistics},
  author={Nevalainen, Shawn},
  year={2025},
  institution={Black River Systems},
  month={December}
}

---
*Status: Experimental / Proof of Concept.*


====================
FILE: ./engine.py
====================
import numpy as np

class QuaternionicSection:
    def __init__(self, a, i, j, k):
        """
        a: Contract Alignment (Real)
        i: Logistical Friction
        j: Temporal Friction
        k: Financial Friction
        """
        self.vector = np.array([a, i, j, k], dtype=float)

    def norm(self):
        # This is the "Public Health Score" (1-10)
        return np.linalg.norm(self.vector)

def generate_handshake_rotation(salt, context_id):
    """
    Creates a deterministic quaternionic rotation 'Seed'.
    This ensures that the 'Stitch' is cryptographically tied 
    to the specific transaction.
    """
    state = hash(f"{salt}-{context_id}")
    np.random.seed(state % (2**32))
    return np.random.standard_normal(4)

def calculate_torsion(section_v1, section_v2):
    """
    The core of the Auditor. 
    It measures the 'Angle' between two sections. 
    Zero means perfect alignment. 
    Anything else is the Waste Stream.
    """
    # Simplified Torsion: The Euclidean distance between quaternionic signatures
    return np.linalg.norm(section_v1.vector - section_v2.vector)

# Test the logic
# v1 = QuaternionicSection(10, 0, 0, 0) # Perfect Contract
# v2 = QuaternionicSection(10, 2, 0, 1) # Logistics and Finance Friction
# print(f"System Torsion: {calculate_torsion(v1, v2)}")


====================
FILE: ./private_core/pwp_core_engine.py
====================
import numpy as np
import hashlib
import secrets
import time

class Quaternion:
    """
    The Atomic Data Type for the White Piece Logic.
    Represents q = a + bi + cj + dk
    """
    def __init__(self, a, b, c, d):
        self.w = float(a) # Scalar (Alpha/Quantity - H0)
        self.x = float(b) # i (Logistic Friction - Primary Entropy)
        self.y = float(c) # j (Temporal Friction)
        self.z = float(d) # k (Financial Friction)

    def __repr__(self):
        return f"({self.w:.2f} + {self.x:.2f}i + {self.y:.2f}j + {self.z:.2f}k)"

    def norm(self):
        # The "Public Heat" metric (Euclidean distance) exposed to the UI
        return np.sqrt(self.w**2 + self.x**2 + self.y**2 + self.z**2)

    def multiply(self, other):
        # Non-commutative Hamilton Product
        w1, x1, y1, z1 = self.w, self.x, self.y, self.z
        w2, x2, y2, z2 = other.w, other.x, other.y, other.z

        return Quaternion(
            w1*w2 - x1*x2 - y1*y2 - z1*z2,
            w1*x2 + x1*w2 + y1*z2 - z1*y2,
            w1*y2 - x1*z2 + y1*w2 + z1*x2,
            w1*z2 + x1*y2 - y1*x2 + z1*w2
        )

    def conjugate(self):
        return Quaternion(self.w, -self.x, -self.y, -self.z)

class SecureEpochVault:
    """
    Implements (2, 3) Threshold Logic with Epoch Shifting.
    Simulates Sovereign-Grade Resilience.
    """
    def __init__(self, master_salt):
        self.epoch_id = 1
        self.master_salt = master_salt
        self.regions = ["US", "EU", "CN"]
        self.active_nodes = ["US", "EU", "CN"] # All healthy initially
        self.polynomial_coeffs = None
        self.shards = {}
        
        # Initialize Epoch 1
        self._generate_epoch_basis()

    def _generate_epoch_basis(self):
        """
        Generates a random polynomial f(x) = Secret + a1*x
        Where 'Secret' is derived from the Master Salt + Current Epoch.
        """
        # 1. Deterministic Secret for this Epoch
        context = f"{self.master_salt}_EPOCH_{self.epoch_id}"
        epoch_secret_int = int(hashlib.sha256(context.encode()).hexdigest(), 16) % (10**10)
        
        # 2. Random slope for the polynomial (The "Noise")
        slope = secrets.randbelow(10**5)
        
        self.polynomial_coeffs = (epoch_secret_int, slope)
        
        # 3. Distribute Shards f(1), f(2), f(3)
        self.shards = {}
        for idx, region in enumerate(self.regions, 1):
            val = epoch_secret_int + (slope * idx)
            self.shards[region] = (idx, val)
            
        print(f"\n[EPOCH {self.epoch_id} ONLINE] Secret distributed via (2, 3) Threshold.")

    def heartbeat_check(self, failing_region=None):
        """
        Simulates a network check. If a region fails, trigger Epoch Shift.
        """
        if failing_region and failing_region in self.active_nodes:
            print(f"‚ö†Ô∏è ALERT: Region_{failing_region} heartbeat lost.")
            self.active_nodes.remove(failing_region)
            self._trigger_epoch_shift()
        else:
            print(f"‚úì Heartbeat Nominal. Active: {self.active_nodes}")

    def _trigger_epoch_shift(self):
        """
        Re-keys the system using the remaining nodes.
        Forward Secrecy: Old keys are mathematically obsolete.
        """
        print(f"‚öôÔ∏è EXECUTING EPOCH SHIFT to Epoch {self.epoch_id + 1}...")
        
        if len(self.active_nodes) < 2:
            raise SystemError("CRITICAL FAILURE: Insufficient nodes for consensus.")
            
        self.epoch_id += 1
        self.shards = {} # FLUSH old shards (Forward Secrecy)
        self._generate_epoch_basis()
        print(f"‚úì RECOVERY COMPLETE. New Basis generated for {self.active_nodes}")

    def synthesize_sheaf_laplacian(self):
        """
        Reconstructs the Secret to generate the Basis Matrix.
        """
        if len(self.active_nodes) < 2:
            return None
            
        context = f"{self.master_salt}_EPOCH_{self.epoch_id}"
        seed_hash = hashlib.sha256(context.encode()).hexdigest()
        np.random.seed(int(seed_hash, 16) % (2**32))
        
        # The Mayer-Vietoris "Shadow Patch"
        return Quaternion(
            1.0, 
            np.random.normal(0, 0.5),  # High Logistic Friction (i)
            np.random.normal(0, 0.1),  # Moderate Temporal Friction (j)
            np.random.normal(0, 0.05)  # Low Financial Friction (k)
        )

# --- EXECUTION TEST ---
if __name__ == "__main__":
    vault = SecureEpochVault("White_Piece_Prime_Key_2025")
    
    # 1. Healthy State
    basis_q = vault.synthesize_sheaf_laplacian()
    print(f"Epoch {vault.epoch_id} Shadow Basis: {basis_q}")
    print(f"Public Norm (Auditable): {basis_q.norm():.4f}")
    
    # 2. Simulate Attack
    print("\n--- SIMULATING GEOPOLITICAL FRACTURE ---")
    vault.heartbeat_check(failing_region="CN")
    
    # 3. Verify Resilience
    new_basis_q = vault.synthesize_sheaf_laplacian()
    print(f"Epoch {vault.epoch_id} Shadow Basis: {new_basis_q}")

====================
FILE: ./private_core/__init__.py
====================

